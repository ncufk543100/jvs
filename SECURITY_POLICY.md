# JARVIS 安全策略与权限控制文档

**版本**: 1.0
**更新日期**: 2026-01-30
**作者**: Manus AI

## 1. 核心安全理念

JARVIS 的安全架构遵循“纵深防御”原则，通过多层次的校验、限制和隔离，确保其在执行任务，尤其是进行自我修改时的稳定性和安全性。其核心理念根植于以下几点：

- **安全优先**: 在功能与安全之间，优先保障系统和数据的安全。所有高风险操作默认都需要确认或被禁止。
- **物理与逻辑隔离**: 关键操作（如代码修改）必须在与主环境隔离的“沙箱”中进行，防止意外破坏。
- **事前校验**: 在应用任何变更之前，必须通过自动化测试（语法检查、功能测试）来验证其正确性和无害性。
- **用户主权**: 最终控制权始终在用户手中。对于有风险的操作，系统会主动请求用户确认，并明确告知潜在风险。
- **最小权限**: 工具和命令的执行被限制在预定义的白名单和功能范围内，避免权限滥用。

## 2. 文件系统访问控制 (读/写/删)

文件系统的访问是 JARVIS 安全模型的基石。所有文件操作都受到严格的路径和权限限制。

### 2.1 沙箱路径限制 (Jailing)

这是最核心的文件安全机制，在 `sandbox.py` 中实现。

> **`assert_in_sandbox(path: str)`**: 这是一个强制性的安全检查函数。任何文件读、写或执行操作之前，目标路径都必须通过此函数校验。它会获取文件的绝对路径，并检查该路径是否位于项目根目录 (`/home/ubuntu/jarvis`) 之内。如果路径越界（例如，尝试访问 `/etc/` 或 `/home/ubuntu/` 等上级目录），将立即抛出 `PermissionError`，从而中止操作。

这个机制有效地将 JARVIS 的所有文件活动“囚禁”在项目目录内，防止其对沙箱环境中的其他文件造成影响。

### 2.2 文件写入策略

- **安全写入**: 通过 `safe_io.py` 中的 `safe_write()` 和 `safe_write_json()` 函数进行。这些函数会自动创建不存在的父目录，这主要是为了程序的健壮性，但也确保了写入操作的可预测性。
- **风险评估**: `executor.py` 将 `write_file` 工具的风险等级标记为“中 (可能覆盖重要文件)”。这意味着 Agent 在决定使用此工具时会更加谨慎，并可能在覆盖关键文件（如配置文件）前征求用户同意。

### 2.3 文件删除策略

JARVIS 对删除操作采取了最严格的控制策略，结合了用户偏好和硬编码规则。

- **强制用户确认**: `user_preferences.json` 中明确设置了 `"delete_requires_confirmation": true`。在 `user_preferences.py` 中，`should_confirm('delete')` 函数被硬编码为始终返回 `True`。这意味着，**任何被定性为“删除”的操作都必须获得用户的明确批准才能执行**。
- **命令白名单**: 虽然 `rm` 和 `del` 命令存在于 `executor.py` 的 `ALLOWED_COMMANDS` 白名单中，但这仅仅意味着 Agent *可以* 构造这些命令。实际执行前，Agent 的决策逻辑会调用确认流程。
- **绝对禁止的命令**: `agent_sovereignty.py` 中包含一个“绝对禁止”的黑名单，如 `rm -rf /`，以防止灾难性的删除操作。

## 3. 命令执行控制

Shell 命令的执行是另一个高风险领域，JARVIS 通过白名单、黑名单和 AI 风险评估相结合的方式进行管控。

| 控制层级 | 实现方式 | 文件位置 | 描述 |
| :--- | :--- | :--- | :--- |
| **白名单** | `ALLOWED_COMMANDS` 列表 | `executor.py` | 仅允许执行列表中预定义的命令，如 `ls`, `git`, `python` 等。 |
| **黑名单** | `forbidden` 列表 | `agent_sovereignty.py` | 绝对禁止执行极度危险的命令，如 `rm -rf /`, `format c:`。 |
| **AI 风险评估** | `assess_action_risk()` | `agent_sovereignty.py` | 对于白名单内但仍有潜在风险的命令，使用 LLM 进行深度的上下文风险评估，判断是继续、拒绝还是请求确认。 |
| **跨平台兼容** | `run_cross_platform_cmd()` | `platform_compatibility.py` | 将 Linux 和 Windows 命令进行转译（如 `rm` -> `del`），确保行为一致性，减少因平台差异导致的安全意外。 |

## 4. 自我修改安全策略

`self_modify.py` 是 JARVIS 安全设计的典范，它展示了如何在没有外部监控的情况下安全地修改自身代码。此流程确保了 Agent 的“进化”过程不会导致“自杀”或系统崩溃。

1.  **启动会话与物理隔离**: `start_session()` 创建一个临时的、与主代码完全隔离的目录 (`/tmp/jarvis_modify_*`)。
2.  **代码备份**: 在隔离目录创建的同时，所有核心 `.py` 文件和配置文件会被完整备份到 `.backups/backup_*` 目录中。
3.  **在隔离区修改**: 所有的代码修改操作 (`modify_temp_file()`) 都只发生在这个临时目录中，不影响正在运行的系统。
4.  **语法检查**: `run_syntax_check()` 使用 `py_compile` 模块检查所有被修改的 Python 文件，确保没有语法错误。
5.  **影子压力测试 (Shadow Server Test)**: 这是最关键的安全步骤。`run_shadow_server_test()` 会：
    -   在临时目录中，使用**修改后**的代码启动一个全新的、运行在随机空闲端口上的“影子服务器”。
    -   向这个影子服务器发送一个真实的测试任务（例如，“列出当前目录的文件”）。
    -   验证影子服务器是否能成功启动、接收任务、正确执行并返回预期的结果。
6.  **原子替换**: **只有在语法检查和影子压力测试全部通过后**，`apply_modifications()` 才会将临时目录中已验证过的文件一次性复制回主代码目录，完成“原子替换”。
7.  **重启与回滚**: 修改应用后，需要调用 `request_restart()` 来重启服务使之生效。如果新代码在启动或运行时出现问题，`rollback()` 函数可以随时从备份目录中恢复所有文件，实现一键回滚。

## 5. 总结

JARVIS 的安全策略是一个综合性的体系，它没有依赖单一的某个安全机制，而是通过分层、冗余和验证的策略，构建了一个健壮的自主操作框架。其核心在于**路径限制**、**用户确认**和创新的**影子压力测试**，这些机制共同确保了 Agent 在拥有强大能力的同时，其行为始终是可控和安全的。
